using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Kitware.mummy.Runtime;

namespace Kitware.VTK
{
	/// <summary>
	///    vtkTrimmedExtrusionFilter
	/// </summary>
	/// <remarks>
	///    extrude polygonal data trimmed by a second input surface
	///
	/// vtkTrimmedExtrusionFilter is a modeling filter. It takes polygonal data as
	/// input and generates polygonal data on output. The input dataset is swept
	/// along a specified direction forming a "skirt" from the boundary edges 2D
	/// primitives (i.e., edges used by only one polygon); and/or from vertices
	/// and lines. The extent of the sweeping is limited by a second input:
	/// defined where the sweep intersects a user-specified surface.
	///
	/// Capping of the extrusion can be enabled. In this case the input,
	/// generating primitive is copied inplace as well as to the end of the
	/// extrusion skirt. (See warnings below on what happens if the intersecting
	/// sweep does not intersect, or partially intersects the trim surface.)
	///
	/// Note that this filter operates in two fundamentally different modes based
	/// on the extrusion strategy. If the strategy is BOUNDARY_EDGES, then only the
	/// boundary edges of the input's 2D primitives are extruded (verts and lines
	/// are extruded to generate lines and quads). However, if the extrusions
	/// strategy is ALL_EDGES, then every edge of the 2D primitives is used to
	/// sweep out a quadrilateral polygon (again verts and lines are swept to
	/// produce lines and quads).
	///
	/// @warning
	/// The extrusion direction is assumed to define an infinite line. The
	/// intersection with the trim surface is along a ray from the - to +
	/// direction, however only the first intersection is taken.
	///
	/// @warning
	/// Some polygonal objects have no free edges (e.g., sphere). When swept, this
	/// will result in two separate surfaces if capping is on and BOUNDARY_EDGES
	/// enabled, or no surface if capping is off and BOUNDARY_EDGES is enabled.
	///
	/// @warning
	/// If all the extrusion lines emanating from an extruding primitive do not
	/// intersect the trim surface, then no output for that primitive will be
	/// generated. In extreme cases, it is possible that no output whatsoever will
	/// be generated by the filter.
	///
	/// @warning
	/// This class has been threaded with vtkSMPTools. Using TBB or other
	/// non-sequential type (set in the CMake variable
	/// VTK_SMP_IMPLEMENTATION_TYPE) may improve performance significantly.
	///
	/// </remarks>
	/// <seealso>
	///
	/// vtkLinearExtrusionFilter vtkRotationalExtrusionFilter
	/// </seealso>
	// Token: 0x02000573 RID: 1395
	public class vtkTrimmedExtrusionFilter : vtkPolyDataAlgorithm
	{
		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x0600F74A RID: 63306 RVA: 0x00157CAB File Offset: 0x00155EAB
		static vtkTrimmedExtrusionFilter()
		{
			Methods.RegisterType(Assembly.GetExecutingAssembly(), vtkTrimmedExtrusionFilter.MRClassNameKey, Type.GetType("Kitware.VTK.vtkTrimmedExtrusionFilter"));
		}

		/// <summary>
		/// Automatically generated constructor - called from generated code.
		/// DO NOT call directly.
		/// </summary>
		// Token: 0x0600F74B RID: 63307 RVA: 0x00157CD3 File Offset: 0x00155ED3
		public vtkTrimmedExtrusionFilter(IntPtr rawCppThis, bool callDisposalMethod, bool strong) : base(rawCppThis, callDisposalMethod, strong)
		{
		}

		// Token: 0x0600F74C RID: 63308
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_New(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Create object with extrusion direction (0,0,1) and capping on.
		/// </summary>
		// Token: 0x0600F74D RID: 63309 RVA: 0x00157CE4 File Offset: 0x00155EE4
		public new static vtkTrimmedExtrusionFilter New()
		{
			vtkTrimmedExtrusionFilter result = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_New(ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				result = (vtkTrimmedExtrusionFilter)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
			}
			return result;
		}

		/// <summary>
		/// Create object with extrusion direction (0,0,1) and capping on.
		/// </summary>
		// Token: 0x0600F74E RID: 63310 RVA: 0x00157D38 File Offset: 0x00155F38
		public vtkTrimmedExtrusionFilter() : base(IntPtr.Zero, false, false)
		{
			uint num = 0U;
			uint maxValue = uint.MaxValue;
			uint num2 = 0U;
			IntPtr rawCppThis = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_New(ref num, ref maxValue, ref num2);
			base.SetCppThis(rawCppThis, true, num != 0U && num2 >= 2U);
		}

		/// <summary>
		/// Automatically generated protected Dispose method - called from
		/// public Dispose or the C# destructor. DO NOT call directly.
		/// </summary>
		// Token: 0x0600F74F RID: 63311 RVA: 0x00157D7C File Offset: 0x00155F7C
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		// Token: 0x0600F750 RID: 63312
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_CappingOff_01(HandleRef pThis);

		/// <summary>
		/// Turn on/off the capping of the extruded skirt.
		/// </summary>
		// Token: 0x0600F751 RID: 63313 RVA: 0x00157D87 File Offset: 0x00155F87
		public virtual void CappingOff()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_CappingOff_01(base.GetCppThis());
		}

		// Token: 0x0600F752 RID: 63314
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_CappingOn_02(HandleRef pThis);

		/// <summary>
		/// Turn on/off the capping of the extruded skirt.
		/// </summary>
		// Token: 0x0600F753 RID: 63315 RVA: 0x00157D96 File Offset: 0x00155F96
		public virtual void CappingOn()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_CappingOn_02(base.GetCppThis());
		}

		// Token: 0x0600F754 RID: 63316
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkTrimmedExtrusionFilter_GetCapping_03(HandleRef pThis);

		/// <summary>
		/// Turn on/off the capping of the extruded skirt.
		/// </summary>
		// Token: 0x0600F755 RID: 63317 RVA: 0x00157DA8 File Offset: 0x00155FA8
		public virtual int GetCapping()
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetCapping_03(base.GetCppThis());
		}

		// Token: 0x0600F756 RID: 63318
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkTrimmedExtrusionFilter_GetCappingStrategy_04(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for capping. By default the points of the cap
		/// polygons are located where the extrusion intersects the capping surface.
		/// However, to preserve planarity, or to place the capping surface at the
		/// average/minimum/maximum distance of extrusion, different strategies can
		/// be used. By default the average distance is used.
		///
		/// Note if none of the extrusion rays intersect the trim surface, then
		/// capping is not performed, nor is an extrusion skirt sent to the
		/// output. Also note that if the capping strategy is set to INTERSECTION,
		/// and one of the extrusion rays of the generating primitive does not
		/// intersect the trim surface, then no output will be generated for that
		/// primitive. However if any other capping strategy is used, capping will
		/// succeed if at least one extrusion ray strikes the trim surface (although
		/// missed extrusion ray intersections will not factor into the
		/// determination of final cap location).
		///
		/// Finally, note that any capping strategy other than INTERSECTION may
		/// produce more points than expected because the output primitives may
		/// have to be "split apart" to satisy the capping constraint.
		/// </summary>
		// Token: 0x0600F757 RID: 63319 RVA: 0x00157DC8 File Offset: 0x00155FC8
		public virtual int GetCappingStrategy()
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetCappingStrategy_04(base.GetCppThis());
		}

		// Token: 0x0600F758 RID: 63320
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_GetExtrusionDirection_05(HandleRef pThis);

		/// <summary>
		/// Set/Get the extrusion direction.
		/// </summary>
		// Token: 0x0600F759 RID: 63321 RVA: 0x00157DE8 File Offset: 0x00155FE8
		public virtual double[] GetExtrusionDirection()
		{
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetExtrusionDirection_05(base.GetCppThis());
			double[] array = null;
			if (IntPtr.Zero != intPtr)
			{
				array = new double[3];
				Marshal.Copy(intPtr, array, 0, array.Length);
			}
			return array;
		}

		// Token: 0x0600F75A RID: 63322
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_GetExtrusionDirection_06(HandleRef pThis, IntPtr data);

		/// <summary>
		/// Set/Get the extrusion direction.
		/// </summary>
		// Token: 0x0600F75B RID: 63323 RVA: 0x00157E30 File Offset: 0x00156030
		public virtual void GetExtrusionDirection(IntPtr data)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetExtrusionDirection_06(base.GetCppThis(), data);
		}

		// Token: 0x0600F75C RID: 63324
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkTrimmedExtrusionFilter_GetExtrusionStrategy_07(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for extrusion. If the strategy is set to
		/// "BOUNDARY_EDGES" then the boundary edges of the input polygons and
		/// triangle strips are swept. (A boundary edge is an edge used by only one
		/// 2D primitive, e.g., polygon or triangle.) Alternatively, all edges can
		/// be swept. (This is particularly useful when only sinple disconnected
		/// polygons exist in the input and so boundary calculation can be avoided.)
		/// By default boundary edges are extruded.
		/// </summary>
		// Token: 0x0600F75D RID: 63325 RVA: 0x00157E40 File Offset: 0x00156040
		public virtual int GetExtrusionStrategy()
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetExtrusionStrategy_07(base.GetCppThis());
		}

		// Token: 0x0600F75E RID: 63326
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_GetLocator_08(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Specify a cell locator. By default a vtkStaticCellLocator is
		/// used. The locator performs efficient searches to intersect cells.
		/// </summary>
		// Token: 0x0600F75F RID: 63327 RVA: 0x00157E60 File Offset: 0x00156060
		public virtual vtkAbstractCellLocator GetLocator()
		{
			vtkAbstractCellLocator vtkAbstractCellLocator = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetLocator_08(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkAbstractCellLocator = (vtkAbstractCellLocator)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkAbstractCellLocator.Register(null);
				}
			}
			return vtkAbstractCellLocator;
		}

		// Token: 0x0600F760 RID: 63328
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkTrimmedExtrusionFilter_GetNumberOfGenerationsFromBase_09(HandleRef pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x0600F761 RID: 63329 RVA: 0x00157ED0 File Offset: 0x001560D0
		public override long GetNumberOfGenerationsFromBase(string type)
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetNumberOfGenerationsFromBase_09(base.GetCppThis(), type);
		}

		// Token: 0x0600F762 RID: 63330
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkTrimmedExtrusionFilter_GetNumberOfGenerationsFromBaseType_10([MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x0600F763 RID: 63331 RVA: 0x00157EF0 File Offset: 0x001560F0
		public new static long GetNumberOfGenerationsFromBaseType(string type)
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetNumberOfGenerationsFromBaseType_10(type);
		}

		// Token: 0x0600F764 RID: 63332
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_GetTrimSurface_11(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Return a pointer to the enclosing surface.
		/// </summary>
		// Token: 0x0600F765 RID: 63333 RVA: 0x00157F0C File Offset: 0x0015610C
		public vtkPolyData GetTrimSurface()
		{
			vtkPolyData vtkPolyData = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetTrimSurface_11(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkPolyData = (vtkPolyData)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkPolyData.Register(null);
				}
			}
			return vtkPolyData;
		}

		// Token: 0x0600F766 RID: 63334
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_GetTrimSurface_12(HandleRef pThis, HandleRef sourceInfo, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Return a pointer to the enclosing surface.
		/// </summary>
		// Token: 0x0600F767 RID: 63335 RVA: 0x00157F7C File Offset: 0x0015617C
		public vtkPolyData GetTrimSurface(vtkInformationVector sourceInfo)
		{
			vtkPolyData vtkPolyData = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_GetTrimSurface_12(base.GetCppThis(), (sourceInfo == null) ? default(HandleRef) : sourceInfo.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkPolyData = (vtkPolyData)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkPolyData.Register(null);
				}
			}
			return vtkPolyData;
		}

		// Token: 0x0600F768 RID: 63336
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkTrimmedExtrusionFilter_IsA_13(HandleRef pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x0600F769 RID: 63337 RVA: 0x00158004 File Offset: 0x00156204
		public override int IsA(string type)
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_IsA_13(base.GetCppThis(), type);
		}

		// Token: 0x0600F76A RID: 63338
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkTrimmedExtrusionFilter_IsTypeOf_14([MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x0600F76B RID: 63339 RVA: 0x00158024 File Offset: 0x00156224
		public new static int IsTypeOf(string type)
		{
			return vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_IsTypeOf_14(type);
		}

		// Token: 0x0600F76C RID: 63340
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_NewInstance_16(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x0600F76D RID: 63341 RVA: 0x00158040 File Offset: 0x00156240
		public new vtkTrimmedExtrusionFilter NewInstance()
		{
			vtkTrimmedExtrusionFilter result = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_NewInstance_16(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				result = (vtkTrimmedExtrusionFilter)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
			}
			return result;
		}

		// Token: 0x0600F76E RID: 63342
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkTrimmedExtrusionFilter_SafeDownCast_17(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x0600F76F RID: 63343 RVA: 0x0015809C File Offset: 0x0015629C
		public new static vtkTrimmedExtrusionFilter SafeDownCast(vtkObjectBase o)
		{
			vtkTrimmedExtrusionFilter vtkTrimmedExtrusionFilter = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SafeDownCast_17((o == null) ? default(HandleRef) : o.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkTrimmedExtrusionFilter = (vtkTrimmedExtrusionFilter)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkTrimmedExtrusionFilter.Register(null);
				}
			}
			return vtkTrimmedExtrusionFilter;
		}

		// Token: 0x0600F770 RID: 63344
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetCapping_18(HandleRef pThis, int _arg);

		/// <summary>
		/// Turn on/off the capping of the extruded skirt.
		/// </summary>
		// Token: 0x0600F771 RID: 63345 RVA: 0x0015811B File Offset: 0x0015631B
		public virtual void SetCapping(int _arg)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetCapping_18(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F772 RID: 63346
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetCappingStrategy_19(HandleRef pThis, int _arg);

		/// <summary>
		/// Specify a strategy for capping. By default the points of the cap
		/// polygons are located where the extrusion intersects the capping surface.
		/// However, to preserve planarity, or to place the capping surface at the
		/// average/minimum/maximum distance of extrusion, different strategies can
		/// be used. By default the average distance is used.
		///
		/// Note if none of the extrusion rays intersect the trim surface, then
		/// capping is not performed, nor is an extrusion skirt sent to the
		/// output. Also note that if the capping strategy is set to INTERSECTION,
		/// and one of the extrusion rays of the generating primitive does not
		/// intersect the trim surface, then no output will be generated for that
		/// primitive. However if any other capping strategy is used, capping will
		/// succeed if at least one extrusion ray strikes the trim surface (although
		/// missed extrusion ray intersections will not factor into the
		/// determination of final cap location).
		///
		/// Finally, note that any capping strategy other than INTERSECTION may
		/// produce more points than expected because the output primitives may
		/// have to be "split apart" to satisy the capping constraint.
		/// </summary>
		// Token: 0x0600F773 RID: 63347 RVA: 0x0015812B File Offset: 0x0015632B
		public virtual void SetCappingStrategy(int _arg)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetCappingStrategy_19(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F774 RID: 63348
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetCappingStrategyToAverageDistance_20(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for capping. By default the points of the cap
		/// polygons are located where the extrusion intersects the capping surface.
		/// However, to preserve planarity, or to place the capping surface at the
		/// average/minimum/maximum distance of extrusion, different strategies can
		/// be used. By default the average distance is used.
		///
		/// Note if none of the extrusion rays intersect the trim surface, then
		/// capping is not performed, nor is an extrusion skirt sent to the
		/// output. Also note that if the capping strategy is set to INTERSECTION,
		/// and one of the extrusion rays of the generating primitive does not
		/// intersect the trim surface, then no output will be generated for that
		/// primitive. However if any other capping strategy is used, capping will
		/// succeed if at least one extrusion ray strikes the trim surface (although
		/// missed extrusion ray intersections will not factor into the
		/// determination of final cap location).
		///
		/// Finally, note that any capping strategy other than INTERSECTION may
		/// produce more points than expected because the output primitives may
		/// have to be "split apart" to satisy the capping constraint.
		/// </summary>
		// Token: 0x0600F775 RID: 63349 RVA: 0x0015813B File Offset: 0x0015633B
		public void SetCappingStrategyToAverageDistance()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetCappingStrategyToAverageDistance_20(base.GetCppThis());
		}

		// Token: 0x0600F776 RID: 63350
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetCappingStrategyToIntersection_21(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for capping. By default the points of the cap
		/// polygons are located where the extrusion intersects the capping surface.
		/// However, to preserve planarity, or to place the capping surface at the
		/// average/minimum/maximum distance of extrusion, different strategies can
		/// be used. By default the average distance is used.
		///
		/// Note if none of the extrusion rays intersect the trim surface, then
		/// capping is not performed, nor is an extrusion skirt sent to the
		/// output. Also note that if the capping strategy is set to INTERSECTION,
		/// and one of the extrusion rays of the generating primitive does not
		/// intersect the trim surface, then no output will be generated for that
		/// primitive. However if any other capping strategy is used, capping will
		/// succeed if at least one extrusion ray strikes the trim surface (although
		/// missed extrusion ray intersections will not factor into the
		/// determination of final cap location).
		///
		/// Finally, note that any capping strategy other than INTERSECTION may
		/// produce more points than expected because the output primitives may
		/// have to be "split apart" to satisy the capping constraint.
		/// </summary>
		// Token: 0x0600F777 RID: 63351 RVA: 0x0015814A File Offset: 0x0015634A
		public void SetCappingStrategyToIntersection()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetCappingStrategyToIntersection_21(base.GetCppThis());
		}

		// Token: 0x0600F778 RID: 63352
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetCappingStrategyToMaximumDistance_22(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for capping. By default the points of the cap
		/// polygons are located where the extrusion intersects the capping surface.
		/// However, to preserve planarity, or to place the capping surface at the
		/// average/minimum/maximum distance of extrusion, different strategies can
		/// be used. By default the average distance is used.
		///
		/// Note if none of the extrusion rays intersect the trim surface, then
		/// capping is not performed, nor is an extrusion skirt sent to the
		/// output. Also note that if the capping strategy is set to INTERSECTION,
		/// and one of the extrusion rays of the generating primitive does not
		/// intersect the trim surface, then no output will be generated for that
		/// primitive. However if any other capping strategy is used, capping will
		/// succeed if at least one extrusion ray strikes the trim surface (although
		/// missed extrusion ray intersections will not factor into the
		/// determination of final cap location).
		///
		/// Finally, note that any capping strategy other than INTERSECTION may
		/// produce more points than expected because the output primitives may
		/// have to be "split apart" to satisy the capping constraint.
		/// </summary>
		// Token: 0x0600F779 RID: 63353 RVA: 0x00158159 File Offset: 0x00156359
		public void SetCappingStrategyToMaximumDistance()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetCappingStrategyToMaximumDistance_22(base.GetCppThis());
		}

		// Token: 0x0600F77A RID: 63354
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetCappingStrategyToMinimumDistance_23(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for capping. By default the points of the cap
		/// polygons are located where the extrusion intersects the capping surface.
		/// However, to preserve planarity, or to place the capping surface at the
		/// average/minimum/maximum distance of extrusion, different strategies can
		/// be used. By default the average distance is used.
		///
		/// Note if none of the extrusion rays intersect the trim surface, then
		/// capping is not performed, nor is an extrusion skirt sent to the
		/// output. Also note that if the capping strategy is set to INTERSECTION,
		/// and one of the extrusion rays of the generating primitive does not
		/// intersect the trim surface, then no output will be generated for that
		/// primitive. However if any other capping strategy is used, capping will
		/// succeed if at least one extrusion ray strikes the trim surface (although
		/// missed extrusion ray intersections will not factor into the
		/// determination of final cap location).
		///
		/// Finally, note that any capping strategy other than INTERSECTION may
		/// produce more points than expected because the output primitives may
		/// have to be "split apart" to satisy the capping constraint.
		/// </summary>
		// Token: 0x0600F77B RID: 63355 RVA: 0x00158168 File Offset: 0x00156368
		public void SetCappingStrategyToMinimumDistance()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetCappingStrategyToMinimumDistance_23(base.GetCppThis());
		}

		// Token: 0x0600F77C RID: 63356
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetExtrusionDirection_24(HandleRef pThis, double _arg1, double _arg2, double _arg3);

		/// <summary>
		/// Set/Get the extrusion direction.
		/// </summary>
		// Token: 0x0600F77D RID: 63357 RVA: 0x00158177 File Offset: 0x00156377
		public virtual void SetExtrusionDirection(double _arg1, double _arg2, double _arg3)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetExtrusionDirection_24(base.GetCppThis(), _arg1, _arg2, _arg3);
		}

		// Token: 0x0600F77E RID: 63358
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetExtrusionDirection_25(HandleRef pThis, IntPtr _arg);

		/// <summary>
		/// Set/Get the extrusion direction.
		/// </summary>
		// Token: 0x0600F77F RID: 63359 RVA: 0x00158189 File Offset: 0x00156389
		public virtual void SetExtrusionDirection(IntPtr _arg)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetExtrusionDirection_25(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F780 RID: 63360
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetExtrusionStrategy_26(HandleRef pThis, int _arg);

		/// <summary>
		/// Specify a strategy for extrusion. If the strategy is set to
		/// "BOUNDARY_EDGES" then the boundary edges of the input polygons and
		/// triangle strips are swept. (A boundary edge is an edge used by only one
		/// 2D primitive, e.g., polygon or triangle.) Alternatively, all edges can
		/// be swept. (This is particularly useful when only sinple disconnected
		/// polygons exist in the input and so boundary calculation can be avoided.)
		/// By default boundary edges are extruded.
		/// </summary>
		// Token: 0x0600F781 RID: 63361 RVA: 0x00158199 File Offset: 0x00156399
		public virtual void SetExtrusionStrategy(int _arg)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetExtrusionStrategy_26(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F782 RID: 63362
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetExtrusionStrategyToAllEdges_27(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for extrusion. If the strategy is set to
		/// "BOUNDARY_EDGES" then the boundary edges of the input polygons and
		/// triangle strips are swept. (A boundary edge is an edge used by only one
		/// 2D primitive, e.g., polygon or triangle.) Alternatively, all edges can
		/// be swept. (This is particularly useful when only sinple disconnected
		/// polygons exist in the input and so boundary calculation can be avoided.)
		/// By default boundary edges are extruded.
		/// </summary>
		// Token: 0x0600F783 RID: 63363 RVA: 0x001581A9 File Offset: 0x001563A9
		public void SetExtrusionStrategyToAllEdges()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetExtrusionStrategyToAllEdges_27(base.GetCppThis());
		}

		// Token: 0x0600F784 RID: 63364
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetExtrusionStrategyToBoundaryEdges_28(HandleRef pThis);

		/// <summary>
		/// Specify a strategy for extrusion. If the strategy is set to
		/// "BOUNDARY_EDGES" then the boundary edges of the input polygons and
		/// triangle strips are swept. (A boundary edge is an edge used by only one
		/// 2D primitive, e.g., polygon or triangle.) Alternatively, all edges can
		/// be swept. (This is particularly useful when only sinple disconnected
		/// polygons exist in the input and so boundary calculation can be avoided.)
		/// By default boundary edges are extruded.
		/// </summary>
		// Token: 0x0600F785 RID: 63365 RVA: 0x001581B8 File Offset: 0x001563B8
		public void SetExtrusionStrategyToBoundaryEdges()
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetExtrusionStrategyToBoundaryEdges_28(base.GetCppThis());
		}

		// Token: 0x0600F786 RID: 63366
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetLocator_29(HandleRef pThis, HandleRef locator);

		/// <summary>
		/// Specify a cell locator. By default a vtkStaticCellLocator is
		/// used. The locator performs efficient searches to intersect cells.
		/// </summary>
		// Token: 0x0600F787 RID: 63367 RVA: 0x001581C8 File Offset: 0x001563C8
		public void SetLocator(vtkAbstractCellLocator locator)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetLocator_29(base.GetCppThis(), (locator == null) ? default(HandleRef) : locator.GetCppThis());
		}

		// Token: 0x0600F788 RID: 63368
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetTrimSurfaceConnection_30(HandleRef pThis, HandleRef algOutput);

		/// <summary>
		/// Specify the surface which trims the surface.  Note that the method
		/// SetTrimSurfaceData does not connect the pipeline. The algorithm will
		/// work on the input data as it is without updating the producer of the
		/// data.  The method SetTrimSurfaceConnection connects the pipeline.
		/// </summary>
		// Token: 0x0600F789 RID: 63369 RVA: 0x001581F8 File Offset: 0x001563F8
		public void SetTrimSurfaceConnection(vtkAlgorithmOutput algOutput)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetTrimSurfaceConnection_30(base.GetCppThis(), (algOutput == null) ? default(HandleRef) : algOutput.GetCppThis());
		}

		// Token: 0x0600F78A RID: 63370
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkTrimmedExtrusionFilter_SetTrimSurfaceData_31(HandleRef pThis, HandleRef pd);

		/// <summary>
		/// Specify the surface which trims the surface.  Note that the method
		/// SetTrimSurfaceData does not connect the pipeline. The algorithm will
		/// work on the input data as it is without updating the producer of the
		/// data.  The method SetTrimSurfaceConnection connects the pipeline.
		/// </summary>
		// Token: 0x0600F78B RID: 63371 RVA: 0x00158228 File Offset: 0x00156428
		public void SetTrimSurfaceData(vtkPolyData pd)
		{
			vtkTrimmedExtrusionFilter.vtkTrimmedExtrusionFilter_SetTrimSurfaceData_31(base.GetCppThis(), (pd == null) ? default(HandleRef) : pd.GetCppThis());
		}

		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x040011F7 RID: 4599
		public new const string MRFullTypeName = "Kitware.VTK.vtkTrimmedExtrusionFilter";

		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x040011F8 RID: 4600
		public new static readonly string MRClassNameKey = "class vtkTrimmedExtrusionFilter";

		/// <summary>
		/// Specify a strategy for extrusion. If the strategy is set to
		/// "BOUNDARY_EDGES" then the boundary edges of the input polygons and
		/// triangle strips are swept. (A boundary edge is an edge used by only one
		/// 2D primitive, e.g., polygon or triangle.) Alternatively, all edges can
		/// be swept. (This is particularly useful when only sinple disconnected
		/// polygons exist in the input and so boundary calculation can be avoided.)
		/// By default boundary edges are extruded.
		/// </summary>
		// Token: 0x02000574 RID: 1396
		public enum CappingStrategy
		{
			/// <summary>enum member</summary>
			// Token: 0x040011FA RID: 4602
			AVERAGE_DISTANCE = 3,
			/// <summary>enum member</summary>
			// Token: 0x040011FB RID: 4603
			INTERSECTION = 0,
			/// <summary>enum member</summary>
			// Token: 0x040011FC RID: 4604
			MAXIMUM_DISTANCE = 2,
			/// <summary>enum member</summary>
			// Token: 0x040011FD RID: 4605
			MINIMUM_DISTANCE = 1
		}

		/// <summary>
		/// Turn on/off the capping of the extruded skirt.
		/// </summary>
		// Token: 0x02000575 RID: 1397
		public enum ExtrusionStrategy
		{
			/// <summary>enum member</summary>
			// Token: 0x040011FF RID: 4607
			ALL_EDGES = 1,
			/// <summary>enum member</summary>
			// Token: 0x04001200 RID: 4608
			BOUNDARY_EDGES = 0
		}
	}
}
