using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Kitware.mummy.Runtime;

namespace Kitware.VTK
{
	/// <summary>
	///    vtkStreamingTessellator
	/// </summary>
	/// <remarks>
	///    An algorithm that refines an initial simplicial tessellation using edge subdivision
	///
	/// This class is a simple algorithm that takes a single starting simplex -- a
	/// tetrahedron, triangle, or line segment -- and calls a function you
	/// pass it with (possibly many times) tetrahedra, triangles, or lines
	/// adaptively sampled from the one you specified. It
	/// uses an algorithm you specify to control the level of adaptivity.
	///
	/// This class does not create vtkUnstructuredGrid output because it is
	/// intended for use in mappers as well as filters. Instead, it
	/// calls the registered function with simplices as they are
	/// created.
	///
	/// The subdivision algorithm should change the vertex
	/// coordinates (it must change both geometric and, if desired, parametric
	/// coordinates) of the midpoint. These coordinates need not be
	/// changed unless the EvaluateLocationAndFields() member returns true.
	/// The vtkStreamingTessellator itself has no way of creating
	/// a more accurate midpoint vertex.
	///
	/// Here's how to use this class:
	/// - Call AdaptivelySample1Facet, AdaptivelySample2Facet, or
	///   AdaptivelySample3Facet, with an edge, triangle, or
	///   tetrahedron you want tessellated.
	/// - The adaptive tessellator classifies each edge by passing
	///   the midpoint values to the vtkEdgeSubdivisionCriterion.
	/// - After each edge is classified, the tessellator subdivides
	///   edges as required until the subdivision criterion is
	///   satisfied or the maximum subdivision depth has been
	///   reached.
	/// - Edges, triangles, or tetrahedra connecting the vertices
	///   generated by the subdivision algorithm are processed by
	///   calling the user-defined callback functions (set with
	///   SetTetrahedronCallback(), SetTriangleCallback(),
	///   or SetEdgeCallback() ).
	///
	/// @warning
	/// Note that the vertices passed to AdaptivelySample3Facet, AdaptivelySample2Facet,
	/// or AdaptivelySample1Facet must be at least 6, 5, or 4 entries long, respectively!
	/// This is because the &amp;lt;r,s,t&amp;gt;, &amp;lt;r,s&amp;gt;, or &amp;lt;r&amp;gt;
	/// parametric coordinates of the vertices are maintained as the
	/// facet is subdivided. This information is often
	/// required by the subdivision algorithm in order to compute
	/// an error metric. You may change the number of parametric coordinates
	/// associated with each vertex using vtkStreamingTessellator::SetEmbeddingDimension().
	///
	/// @par Interpolating Field Values:
	/// If you wish, you may also use \p vtkStreamingTessellator to interpolate field
	/// values at newly created vertices. Interpolated field values are stored just beyond
	/// the parametric coordinates associated with a vertex. They will always be \p double
	/// values; it does not make sense to interpolate a boolean or string value and your
	/// output and subdivision subroutines may always cast to a \p float or use \p floor() to
	/// truncate an interpolated value to an integer.
	///
	/// </remarks>
	/// <seealso>
	///
	/// vtkEdgeSubdivisionCriterion
	/// </seealso>
	// Token: 0x020009A1 RID: 2465
	public class vtkStreamingTessellator : vtkObject
	{
		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x06019C69 RID: 105577 RVA: 0x0023CE89 File Offset: 0x0023B089
		static vtkStreamingTessellator()
		{
			Methods.RegisterType(Assembly.GetExecutingAssembly(), vtkStreamingTessellator.MRClassNameKey, Type.GetType("Kitware.VTK.vtkStreamingTessellator"));
		}

		/// <summary>
		/// Automatically generated constructor - called from generated code.
		/// DO NOT call directly.
		/// </summary>
		// Token: 0x06019C6A RID: 105578 RVA: 0x0023CEB1 File Offset: 0x0023B0B1
		public vtkStreamingTessellator(IntPtr rawCppThis, bool callDisposalMethod, bool strong) : base(rawCppThis, callDisposalMethod, strong)
		{
		}

		// Token: 0x06019C6B RID: 105579
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkStreamingTessellator_New(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C6C RID: 105580 RVA: 0x0023CEC0 File Offset: 0x0023B0C0
		public new static vtkStreamingTessellator New()
		{
			vtkStreamingTessellator result = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkStreamingTessellator.vtkStreamingTessellator_New(ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				result = (vtkStreamingTessellator)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
			}
			return result;
		}

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C6D RID: 105581 RVA: 0x0023CF14 File Offset: 0x0023B114
		public vtkStreamingTessellator() : base(IntPtr.Zero, false, false)
		{
			uint num = 0U;
			uint maxValue = uint.MaxValue;
			uint num2 = 0U;
			IntPtr rawCppThis = vtkStreamingTessellator.vtkStreamingTessellator_New(ref num, ref maxValue, ref num2);
			base.SetCppThis(rawCppThis, true, num != 0U && num2 >= 2U);
		}

		/// <summary>
		/// Automatically generated protected Dispose method - called from
		/// public Dispose or the C# destructor. DO NOT call directly.
		/// </summary>
		// Token: 0x06019C6E RID: 105582 RVA: 0x0023CF58 File Offset: 0x0023B158
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		// Token: 0x06019C6F RID: 105583
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample0Facet_01(HandleRef pThis, IntPtr v0);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C70 RID: 105584 RVA: 0x0023CF63 File Offset: 0x0023B163
		public void AdaptivelySample0Facet(IntPtr v0)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample0Facet_01(base.GetCppThis(), v0);
		}

		// Token: 0x06019C71 RID: 105585
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample1Facet_02(HandleRef pThis, IntPtr v0, IntPtr v1);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C72 RID: 105586 RVA: 0x0023CF73 File Offset: 0x0023B173
		public void AdaptivelySample1Facet(IntPtr v0, IntPtr v1)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample1Facet_02(base.GetCppThis(), v0, v1);
		}

		// Token: 0x06019C73 RID: 105587
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample1FacetLinear_03(HandleRef pThis, IntPtr v0, IntPtr v1);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C74 RID: 105588 RVA: 0x0023CF84 File Offset: 0x0023B184
		public void AdaptivelySample1FacetLinear(IntPtr v0, IntPtr v1)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample1FacetLinear_03(base.GetCppThis(), v0, v1);
		}

		// Token: 0x06019C75 RID: 105589
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample2Facet_04(HandleRef pThis, IntPtr v0, IntPtr v1, IntPtr v2);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C76 RID: 105590 RVA: 0x0023CF95 File Offset: 0x0023B195
		public void AdaptivelySample2Facet(IntPtr v0, IntPtr v1, IntPtr v2)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample2Facet_04(base.GetCppThis(), v0, v1, v2);
		}

		// Token: 0x06019C77 RID: 105591
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample2FacetLinear_05(HandleRef pThis, IntPtr v0, IntPtr v1, IntPtr v2);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C78 RID: 105592 RVA: 0x0023CFA7 File Offset: 0x0023B1A7
		public void AdaptivelySample2FacetLinear(IntPtr v0, IntPtr v1, IntPtr v2)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample2FacetLinear_05(base.GetCppThis(), v0, v1, v2);
		}

		// Token: 0x06019C79 RID: 105593
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample3Facet_06(HandleRef pThis, IntPtr v0, IntPtr v1, IntPtr v2, IntPtr v3);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C7A RID: 105594 RVA: 0x0023CFB9 File Offset: 0x0023B1B9
		public void AdaptivelySample3Facet(IntPtr v0, IntPtr v1, IntPtr v2, IntPtr v3)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample3Facet_06(base.GetCppThis(), v0, v1, v2, v3);
		}

		// Token: 0x06019C7B RID: 105595
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_AdaptivelySample3FacetLinear_07(HandleRef pThis, IntPtr v0, IntPtr v1, IntPtr v2, IntPtr v3);

		/// <summary>
		/// This will adaptively subdivide the tetrahedron (3-facet),
		/// triangle (2-facet), or edge (1-facet) until the subdivision
		/// algorithm returns false for every edge or the maximum recursion
		/// depth is reached.
		///
		/// Use \p SetMaximumNumberOfSubdivisions to change the maximum
		/// recursion depth.
		///
		/// The AdaptivelySample0Facet method is provided as a convenience.
		/// Obviously, there is no way to adaptively subdivide a vertex.
		/// Instead the input vertex is passed unchanged to the output
		/// via a call to the registered VertexProcessorFunction callback.
		///
		/// .SECTION Warning
		/// This assumes that you have called SetSubdivisionAlgorithm(),
		/// SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
		/// with valid values!
		/// </summary>
		// Token: 0x06019C7C RID: 105596 RVA: 0x0023CFCD File Offset: 0x0023B1CD
		public void AdaptivelySample3FacetLinear(IntPtr v0, IntPtr v1, IntPtr v2, IntPtr v3)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_AdaptivelySample3FacetLinear_07(base.GetCppThis(), v0, v1, v2, v3);
		}

		// Token: 0x06019C7D RID: 105597
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkStreamingTessellator_GetCaseCount_08(HandleRef pThis, int c);

		/// <summary>
		/// Reset/access the histogram of subdivision cases encountered.
		/// The histogram may be used to examine coverage during testing as well as characterizing the
		/// tessellation algorithm's performance.
		/// You should call ResetCounts() once, at the beginning of a stream of tetrahedra.
		/// It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.
		///
		/// These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been
		///             defined.
		/// By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and
		///             efficient. Really!
		/// </summary>
		// Token: 0x06019C7E RID: 105598 RVA: 0x0023CFE4 File Offset: 0x0023B1E4
		public long GetCaseCount(int c)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetCaseCount_08(base.GetCppThis(), c);
		}

		// Token: 0x06019C7F RID: 105599
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkStreamingTessellator_GetConstPrivateData_09(HandleRef pThis);

		/// <summary>
		/// Get/Set a constant void pointer passed to the simplex output functions.
		/// </summary>
		// Token: 0x06019C80 RID: 105600 RVA: 0x0023D004 File Offset: 0x0023B204
		public virtual IntPtr GetConstPrivateData()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetConstPrivateData_09(base.GetCppThis());
		}

		// Token: 0x06019C81 RID: 105601
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern vtkStreamingTessellator.EdgeProcessorFunction vtkStreamingTessellator_GetEdgeCallback_10(HandleRef pThis);

		/// <summary>
		/// Get/Set the function called for each output line segment (1-facet).
		/// </summary>
		// Token: 0x06019C82 RID: 105602 RVA: 0x0023D024 File Offset: 0x0023B224
		public virtual vtkStreamingTessellator.EdgeProcessorFunction GetEdgeCallback()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetEdgeCallback_10(base.GetCppThis());
		}

		// Token: 0x06019C83 RID: 105603
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkStreamingTessellator_GetEmbeddingDimension_11(HandleRef pThis, int k);

		/// <summary>
		/// Get/Set the number of parameter-space coordinates associated with each input and output point.
		/// The default is \a k for \a k -facets. You may
		/// specify a different dimension, \a d, for each type of \a k -facet to be processed.
		/// For example, \p SetEmbeddingDimension( \p 2, \p 3 ) would associate \a r, \a s, and
		/// \a t coordinates with each input and output point generated by \p AdaptivelySample2Facet
		/// but does not say anything about input or output points generated by
		/// \p AdaptivelySample1Facet.
		/// Call \p SetEmbeddingDimension( \p -1, \a d ) to specify the same dimension for
		/// all possible \a k values.
		/// \a d may not exceed 8, as that would be plain silly.
		/// </summary>
		// Token: 0x06019C84 RID: 105604 RVA: 0x0023D044 File Offset: 0x0023B244
		public int GetEmbeddingDimension(int k)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetEmbeddingDimension_11(base.GetCppThis(), k);
		}

		// Token: 0x06019C85 RID: 105605
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkStreamingTessellator_GetFieldSize_12(HandleRef pThis, int k);

		/// <summary>
		/// Get/Set the number of field value coordinates associated with each input and output point.
		/// The default is 0; no field values are interpolated.
		/// You may specify a different size, \a s, for each type of \a k -facet to be processed.
		/// For example, \p SetFieldSize( \p 2, \p 3 ) would associate 3 field value coordinates
		/// with each input and output point of an \p AdaptivelySample2Facet call,
		/// but does not say anything about input or output points of \p AdaptivelySample1Facet.
		/// Call \p SetFieldSize( \p -1, \a s ) to specify the same dimension for all possible \a k values.
		/// \a s may not exceed vtkStreamingTessellator::MaxFieldSize.
		/// This is a compile-time constant that defaults to 18, which is large enough for
		/// a scalar, vector, tensor, normal, and texture coordinate to be included at each point.
		///
		/// Normally, you will not call \a SetFieldSize() directly; instead, subclasses of
		/// vtkEdgeSubdivisionCriterion, such as vtkShoeMeshSubdivisionAlgorithm, will call it
		/// for you.
		///
		/// In any event, setting \a FieldSize to a non-zero value means you must pass field
		/// values to the \p AdaptivelySamplekFacet routines; For example,
		/// @verbatim
		/// vtkStreamingTessellator* t = vtkStreamingTessellator::New();
		/// t-&gt;SetFieldSize( 1, 3 );
		/// t-&gt;SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
		/// double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
		/// double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
		/// t-&gt;AdaptivelySample1Facet( p0, p1 );
		/// @endverbatim
		/// This would adaptively sample an curve (1-facet) with geometry and
		/// a vector field at every output point on the curve.
		/// </summary>
		// Token: 0x06019C86 RID: 105606 RVA: 0x0023D064 File Offset: 0x0023B264
		public int GetFieldSize(int k)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetFieldSize_12(base.GetCppThis(), k);
		}

		// Token: 0x06019C87 RID: 105607
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkStreamingTessellator_GetMaximumNumberOfSubdivisions_13(HandleRef pThis);

		/// <summary>
		/// Get/Set the maximum number of subdivisions that may occur.
		/// </summary>
		// Token: 0x06019C88 RID: 105608 RVA: 0x0023D084 File Offset: 0x0023B284
		public int GetMaximumNumberOfSubdivisions()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetMaximumNumberOfSubdivisions_13(base.GetCppThis());
		}

		// Token: 0x06019C89 RID: 105609
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkStreamingTessellator_GetNumberOfGenerationsFromBase_14(HandleRef pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C8A RID: 105610 RVA: 0x0023D0A4 File Offset: 0x0023B2A4
		public override long GetNumberOfGenerationsFromBase(string type)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetNumberOfGenerationsFromBase_14(base.GetCppThis(), type);
		}

		// Token: 0x06019C8B RID: 105611
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkStreamingTessellator_GetNumberOfGenerationsFromBaseType_15([MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C8C RID: 105612 RVA: 0x0023D0C4 File Offset: 0x0023B2C4
		public new static long GetNumberOfGenerationsFromBaseType(string type)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetNumberOfGenerationsFromBaseType_15(type);
		}

		// Token: 0x06019C8D RID: 105613
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkStreamingTessellator_GetPrivateData_16(HandleRef pThis);

		/// <summary>
		/// Get/Set a void pointer passed to the triangle and edge output functions.
		/// </summary>
		// Token: 0x06019C8E RID: 105614 RVA: 0x0023D0E0 File Offset: 0x0023B2E0
		public virtual IntPtr GetPrivateData()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetPrivateData_16(base.GetCppThis());
		}

		// Token: 0x06019C8F RID: 105615
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkStreamingTessellator_GetSubcaseCount_17(HandleRef pThis, int casenum, int sub);

		/// <summary>
		/// Reset/access the histogram of subdivision cases encountered.
		/// The histogram may be used to examine coverage during testing as well as characterizing the
		/// tessellation algorithm's performance.
		/// You should call ResetCounts() once, at the beginning of a stream of tetrahedra.
		/// It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.
		///
		/// These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been
		///             defined.
		/// By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and
		///             efficient. Really!
		/// </summary>
		// Token: 0x06019C90 RID: 105616 RVA: 0x0023D100 File Offset: 0x0023B300
		public long GetSubcaseCount(int casenum, int sub)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetSubcaseCount_17(base.GetCppThis(), casenum, sub);
		}

		// Token: 0x06019C91 RID: 105617
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkStreamingTessellator_GetSubdivisionAlgorithm_18(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Get/Set the algorithm used to determine whether an edge should be
		/// subdivided or left as-is. This is used once for each call to
		/// AdaptivelySample1Facet (which is recursive and will call itself
		/// resulting in additional edges to be checked) or three times for
		/// each call to AdaptivelySample2Facet (also recursive).
		/// </summary>
		// Token: 0x06019C92 RID: 105618 RVA: 0x0023D124 File Offset: 0x0023B324
		public virtual vtkEdgeSubdivisionCriterion GetSubdivisionAlgorithm()
		{
			vtkEdgeSubdivisionCriterion vtkEdgeSubdivisionCriterion = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkStreamingTessellator.vtkStreamingTessellator_GetSubdivisionAlgorithm_18(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkEdgeSubdivisionCriterion = (vtkEdgeSubdivisionCriterion)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkEdgeSubdivisionCriterion.Register(null);
				}
			}
			return vtkEdgeSubdivisionCriterion;
		}

		// Token: 0x06019C93 RID: 105619
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern vtkStreamingTessellator.TetrahedronProcessorFunction vtkStreamingTessellator_GetTetrahedronCallback_19(HandleRef pThis);

		/// <summary>
		/// Get/Set the function called for each output tetrahedron (3-facet).
		/// </summary>
		// Token: 0x06019C94 RID: 105620 RVA: 0x0023D194 File Offset: 0x0023B394
		public virtual vtkStreamingTessellator.TetrahedronProcessorFunction GetTetrahedronCallback()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetTetrahedronCallback_19(base.GetCppThis());
		}

		// Token: 0x06019C95 RID: 105621
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern vtkStreamingTessellator.TriangleProcessorFunction vtkStreamingTessellator_GetTriangleCallback_20(HandleRef pThis);

		/// <summary>
		/// Get/Set the function called for each output triangle (2-facet).
		/// </summary>
		// Token: 0x06019C96 RID: 105622 RVA: 0x0023D1B4 File Offset: 0x0023B3B4
		public virtual vtkStreamingTessellator.TriangleProcessorFunction GetTriangleCallback()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetTriangleCallback_20(base.GetCppThis());
		}

		// Token: 0x06019C97 RID: 105623
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern vtkStreamingTessellator.VertexProcessorFunction vtkStreamingTessellator_GetVertexCallback_21(HandleRef pThis);

		/// <summary>
		/// Get/Set the function called for each output line segment (1-facet).
		/// </summary>
		// Token: 0x06019C98 RID: 105624 RVA: 0x0023D1D4 File Offset: 0x0023B3D4
		public virtual vtkStreamingTessellator.VertexProcessorFunction GetVertexCallback()
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_GetVertexCallback_21(base.GetCppThis());
		}

		// Token: 0x06019C99 RID: 105625
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkStreamingTessellator_IsA_22(HandleRef pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C9A RID: 105626 RVA: 0x0023D1F4 File Offset: 0x0023B3F4
		public override int IsA(string type)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_IsA_22(base.GetCppThis(), type);
		}

		// Token: 0x06019C9B RID: 105627
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkStreamingTessellator_IsTypeOf_23([MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C9C RID: 105628 RVA: 0x0023D214 File Offset: 0x0023B414
		public new static int IsTypeOf(string type)
		{
			return vtkStreamingTessellator.vtkStreamingTessellator_IsTypeOf_23(type);
		}

		// Token: 0x06019C9D RID: 105629
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkStreamingTessellator_NewInstance_25(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019C9E RID: 105630 RVA: 0x0023D230 File Offset: 0x0023B430
		public new vtkStreamingTessellator NewInstance()
		{
			vtkStreamingTessellator result = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkStreamingTessellator.vtkStreamingTessellator_NewInstance_25(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				result = (vtkStreamingTessellator)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
			}
			return result;
		}

		// Token: 0x06019C9F RID: 105631
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_ResetCounts_26(HandleRef pThis);

		/// <summary>
		/// Reset/access the histogram of subdivision cases encountered.
		/// The histogram may be used to examine coverage during testing as well as characterizing the
		/// tessellation algorithm's performance.
		/// You should call ResetCounts() once, at the beginning of a stream of tetrahedra.
		/// It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.
		///
		/// These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been
		///             defined.
		/// By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and
		///             efficient. Really!
		/// </summary>
		// Token: 0x06019CA0 RID: 105632 RVA: 0x0023D28A File Offset: 0x0023B48A
		public void ResetCounts()
		{
			vtkStreamingTessellator.vtkStreamingTessellator_ResetCounts_26(base.GetCppThis());
		}

		// Token: 0x06019CA1 RID: 105633
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkStreamingTessellator_SafeDownCast_27(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x06019CA2 RID: 105634 RVA: 0x0023D29C File Offset: 0x0023B49C
		public new static vtkStreamingTessellator SafeDownCast(vtkObjectBase o)
		{
			vtkStreamingTessellator vtkStreamingTessellator = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkStreamingTessellator.vtkStreamingTessellator_SafeDownCast_27((o == null) ? default(HandleRef) : o.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkStreamingTessellator = (vtkStreamingTessellator)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkStreamingTessellator.Register(null);
				}
			}
			return vtkStreamingTessellator;
		}

		// Token: 0x06019CA3 RID: 105635
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetConstPrivateData_28(HandleRef pThis, IntPtr ConstPrivate);

		/// <summary>
		/// Get/Set a constant void pointer passed to the simplex output functions.
		/// </summary>
		// Token: 0x06019CA4 RID: 105636 RVA: 0x0023D31B File Offset: 0x0023B51B
		public virtual void SetConstPrivateData(IntPtr ConstPrivate)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetConstPrivateData_28(base.GetCppThis(), ConstPrivate);
		}

		// Token: 0x06019CA5 RID: 105637
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetEdgeCallback_29(HandleRef pThis, vtkStreamingTessellator.EdgeProcessorFunction arg0);

		/// <summary>
		/// Get/Set the function called for each output line segment (1-facet).
		/// </summary>
		// Token: 0x06019CA6 RID: 105638 RVA: 0x0023D32B File Offset: 0x0023B52B
		public virtual void SetEdgeCallback(vtkStreamingTessellator.EdgeProcessorFunction arg0)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetEdgeCallback_29(base.GetCppThis(), arg0);
		}

		// Token: 0x06019CA7 RID: 105639
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetEmbeddingDimension_30(HandleRef pThis, int k, int d);

		/// <summary>
		/// Get/Set the number of parameter-space coordinates associated with each input and output point.
		/// The default is \a k for \a k -facets. You may
		/// specify a different dimension, \a d, for each type of \a k -facet to be processed.
		/// For example, \p SetEmbeddingDimension( \p 2, \p 3 ) would associate \a r, \a s, and
		/// \a t coordinates with each input and output point generated by \p AdaptivelySample2Facet
		/// but does not say anything about input or output points generated by
		/// \p AdaptivelySample1Facet.
		/// Call \p SetEmbeddingDimension( \p -1, \a d ) to specify the same dimension for
		/// all possible \a k values.
		/// \a d may not exceed 8, as that would be plain silly.
		/// </summary>
		// Token: 0x06019CA8 RID: 105640 RVA: 0x0023D33B File Offset: 0x0023B53B
		public virtual void SetEmbeddingDimension(int k, int d)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetEmbeddingDimension_30(base.GetCppThis(), k, d);
		}

		// Token: 0x06019CA9 RID: 105641
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetFieldSize_31(HandleRef pThis, int k, int s);

		/// <summary>
		/// Get/Set the number of field value coordinates associated with each input and output point.
		/// The default is 0; no field values are interpolated.
		/// You may specify a different size, \a s, for each type of \a k -facet to be processed.
		/// For example, \p SetFieldSize( \p 2, \p 3 ) would associate 3 field value coordinates
		/// with each input and output point of an \p AdaptivelySample2Facet call,
		/// but does not say anything about input or output points of \p AdaptivelySample1Facet.
		/// Call \p SetFieldSize( \p -1, \a s ) to specify the same dimension for all possible \a k values.
		/// \a s may not exceed vtkStreamingTessellator::MaxFieldSize.
		/// This is a compile-time constant that defaults to 18, which is large enough for
		/// a scalar, vector, tensor, normal, and texture coordinate to be included at each point.
		///
		/// Normally, you will not call \a SetFieldSize() directly; instead, subclasses of
		/// vtkEdgeSubdivisionCriterion, such as vtkShoeMeshSubdivisionAlgorithm, will call it
		/// for you.
		///
		/// In any event, setting \a FieldSize to a non-zero value means you must pass field
		/// values to the \p AdaptivelySamplekFacet routines; For example,
		/// @verbatim
		/// vtkStreamingTessellator* t = vtkStreamingTessellator::New();
		/// t-&gt;SetFieldSize( 1, 3 );
		/// t-&gt;SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
		/// double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
		/// double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
		/// t-&gt;AdaptivelySample1Facet( p0, p1 );
		/// @endverbatim
		/// This would adaptively sample an curve (1-facet) with geometry and
		/// a vector field at every output point on the curve.
		/// </summary>
		// Token: 0x06019CAA RID: 105642 RVA: 0x0023D34C File Offset: 0x0023B54C
		public virtual void SetFieldSize(int k, int s)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetFieldSize_31(base.GetCppThis(), k, s);
		}

		// Token: 0x06019CAB RID: 105643
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetMaximumNumberOfSubdivisions_32(HandleRef pThis, int num_subdiv_in);

		/// <summary>
		/// Get/Set the maximum number of subdivisions that may occur.
		/// </summary>
		// Token: 0x06019CAC RID: 105644 RVA: 0x0023D35D File Offset: 0x0023B55D
		public virtual void SetMaximumNumberOfSubdivisions(int num_subdiv_in)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetMaximumNumberOfSubdivisions_32(base.GetCppThis(), num_subdiv_in);
		}

		// Token: 0x06019CAD RID: 105645
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetPrivateData_33(HandleRef pThis, IntPtr Private);

		/// <summary>
		/// Get/Set a void pointer passed to the triangle and edge output functions.
		/// </summary>
		// Token: 0x06019CAE RID: 105646 RVA: 0x0023D36D File Offset: 0x0023B56D
		public virtual void SetPrivateData(IntPtr Private)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetPrivateData_33(base.GetCppThis(), Private);
		}

		// Token: 0x06019CAF RID: 105647
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetSubdivisionAlgorithm_34(HandleRef pThis, HandleRef arg0);

		/// <summary>
		/// Get/Set the algorithm used to determine whether an edge should be
		/// subdivided or left as-is. This is used once for each call to
		/// AdaptivelySample1Facet (which is recursive and will call itself
		/// resulting in additional edges to be checked) or three times for
		/// each call to AdaptivelySample2Facet (also recursive).
		/// </summary>
		// Token: 0x06019CB0 RID: 105648 RVA: 0x0023D380 File Offset: 0x0023B580
		public virtual void SetSubdivisionAlgorithm(vtkEdgeSubdivisionCriterion arg0)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetSubdivisionAlgorithm_34(base.GetCppThis(), (arg0 == null) ? default(HandleRef) : arg0.GetCppThis());
		}

		// Token: 0x06019CB1 RID: 105649
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetTetrahedronCallback_35(HandleRef pThis, vtkStreamingTessellator.TetrahedronProcessorFunction arg0);

		/// <summary>
		/// Get/Set the function called for each output tetrahedron (3-facet).
		/// </summary>
		// Token: 0x06019CB2 RID: 105650 RVA: 0x0023D3AF File Offset: 0x0023B5AF
		public virtual void SetTetrahedronCallback(vtkStreamingTessellator.TetrahedronProcessorFunction arg0)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetTetrahedronCallback_35(base.GetCppThis(), arg0);
		}

		// Token: 0x06019CB3 RID: 105651
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetTriangleCallback_36(HandleRef pThis, vtkStreamingTessellator.TriangleProcessorFunction arg0);

		/// <summary>
		/// Get/Set the function called for each output triangle (2-facet).
		/// </summary>
		// Token: 0x06019CB4 RID: 105652 RVA: 0x0023D3BF File Offset: 0x0023B5BF
		public virtual void SetTriangleCallback(vtkStreamingTessellator.TriangleProcessorFunction arg0)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetTriangleCallback_36(base.GetCppThis(), arg0);
		}

		// Token: 0x06019CB5 RID: 105653
		[DllImport("Kitware.VTK.FiltersCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkStreamingTessellator_SetVertexCallback_37(HandleRef pThis, vtkStreamingTessellator.VertexProcessorFunction arg0);

		/// <summary>
		/// Get/Set the function called for each output line segment (1-facet).
		/// </summary>
		// Token: 0x06019CB6 RID: 105654 RVA: 0x0023D3CF File Offset: 0x0023B5CF
		public virtual void SetVertexCallback(vtkStreamingTessellator.VertexProcessorFunction arg0)
		{
			vtkStreamingTessellator.vtkStreamingTessellator_SetVertexCallback_37(base.GetCppThis(), arg0);
		}

		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x04001C07 RID: 7175
		public new const string MRFullTypeName = "Kitware.VTK.vtkStreamingTessellator";

		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x04001C08 RID: 7176
		public new static readonly string MRClassNameKey = "class vtkStreamingTessellator";

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x020009A2 RID: 2466
		public enum MaxFieldSize_WrapperEnum
		{
			/// <summary>enum member</summary>
			// Token: 0x04001C0A RID: 7178
			MaxFieldSize = 18
		}

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x020009A3 RID: 2467
		// (Invoke) Token: 0x06019CB8 RID: 105656
		public delegate void EdgeProcessorFunction(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x020009A4 RID: 2468
		// (Invoke) Token: 0x06019CBC RID: 105660
		public delegate void TetrahedronProcessorFunction(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5, IntPtr arg6);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x020009A5 RID: 2469
		// (Invoke) Token: 0x06019CC0 RID: 105664
		public delegate void TriangleProcessorFunction(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3, IntPtr arg4, IntPtr arg5);

		/// <summary>
		///             Undocumented Block
		/// </summary>
		// Token: 0x020009A6 RID: 2470
		// (Invoke) Token: 0x06019CC4 RID: 105668
		public delegate void VertexProcessorFunction(IntPtr arg0, IntPtr arg1, IntPtr arg2, IntPtr arg3);
	}
}
