using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Kitware.mummy.Runtime;

namespace Kitware.VTK
{
	/// <summary>
	///    vtkImprintFilter
	/// </summary>
	/// <remarks>
	///    Imprint the contact surface of one object onto another surface
	///
	/// This filter imprints the contact surface of one vtkPolyData mesh onto
	/// a second, input vtkPolyData mesh. There are two inputs to the filter:
	/// the target, which is the surface to be imprinted, and the imprint, which
	/// is the object imprinting the target.
	///
	/// A high level overview of the algorithm is as follows. 1) The target cells
	/// are segregated into two subsets: those that may intersect the imprint
	/// surface (the candidate cells determined by bounding box checks), and those
	/// that do not. 2) The non-candidates are sent to the output, the candidate
	/// intersection cells are further processed - eventually they will be
	/// triangulated as a result of contact with the imprint, with the result of
	/// the triangulation appended to the output. 3) The imprint points are projected
	/// onto the candidate cells, determining a classification (on a target point,
	/// on a target edge, interior to a target cell, outside the target).  4) The
	/// non-outside imprint points are associated with one or more target cells.
	/// 5) The imprint edges are intersected with the target cell edges, producing
	/// additional points associated with the the candidate cells, as well as
	/// "fragments" or portions of edges associated with the candidate target
	/// cells. 6) On a per-candidate-target-cell basis, the points and edge
	/// fragments associated with that cell are used to triangulate the cell.
	/// 7) Finally, the triangulated target cells are appended to the output.
	///
	/// Several options exist to specify how to produce an output cell data array
	/// that indicates whether the output cells are in the imprinted area. If
	/// enabled, this output vtkSignedCharArray will have a value=1 for cells that
	/// are in the imprinted area. Otherwise, the value=0 is indicating the cell
	/// is not in contact with the imprinted area. The name of this cell data
	/// array is "ImprintedCells".
	///
	/// The filter also has the option to pass through and generate point and cell
	/// data.  If PassCellData is enabled, then the cell data associated with the
	/// cropped cells, or cells passed through from the input mesh, are passed
	/// through to the output. If PassPointData is enabled, then in similar
	/// fashion the point data is passed through; however new points generated by
	/// intersection may have point data interpolated in one of two ways. First,
	/// the target mesh edges are interpolated at the new intersection points to
	/// generate point data, or the imprint edges are interpolated at the new
	/// intersection points to generate point data. Note: for PassPointData and
	/// point interpolation to function, the filter requires that the point data
	/// attributes (from the target mesh and imprint mesh) are exactly the
	/// same. If they are not, then a set intersection operation is performed that
	/// uses the point data arrays common to both the target and imprint meshes.
	///
	/// Some notes:
	/// -- The algorithm assumes that the input target and imprint cells are convex.
	/// -- If performing a PROJECTED_IMPRINT, the output is the imprint mesh with
	///    the point coordinates modified by projecting the imprint points onto
	///    the target. If the profection of an imprint point onto the target is
	///    unsuccessful, the imprint point coordinates are not modified.
	/// -- If performing a MERGED_IMPRINT, the number of output points is
	///    (numTargetPts + numImprintPts + numEdgeIntPts).
	/// -- Not all of the output points may be used, for example if an imprint point
	///    is coincident (within the tolerance) of a target point, the target point
	///    replaces the imprint point.
	/// -- Candidate cells which may reside within the bounding box of the imprint
	///    but may not actually intersect the imprint will be appended to the output
	///    without triangulation.
	/// -- Candidate cells that are intersected will be triangulated: i.e., triangles
	///    will be produced and appended to the output.
	/// -- Triangulation requires combining the points and edge fragments associated
	///    with each target candidate cell, as well as the candidate cell's defining
	///    points and edges, to produce the final triangulation.
	/// -- Portions of the algorithm are SMP threaded. For example, steps #1 and #2
	///    (candidate segregation); point projection step #3; cell triangulation
	///    step #6. Future implementations may further parallelize the algorithm.
	/// -- The algorithm produces an output cell data array that indicates
	///    which output cells are in the imprinted area. This vtkSignedCharArray
	///    has a value=0 for cells that were originally target cells; a value=2
	///    for output cells that are in the imprinted region; and a value=1 for
	///    cells that are in the transition region (between target and imprinted
	///    cells). The name of this cell data array is "ImprintedCells".
	///
	/// </remarks>
	// Token: 0x0200055A RID: 1370
	public class vtkImprintFilter : vtkPolyDataAlgorithm
	{
		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x0600F31F RID: 62239 RVA: 0x00152BC3 File Offset: 0x00150DC3
		static vtkImprintFilter()
		{
			Methods.RegisterType(Assembly.GetExecutingAssembly(), vtkImprintFilter.MRClassNameKey, Type.GetType("Kitware.VTK.vtkImprintFilter"));
		}

		/// <summary>
		/// Automatically generated constructor - called from generated code.
		/// DO NOT call directly.
		/// </summary>
		// Token: 0x0600F320 RID: 62240 RVA: 0x00152BEB File Offset: 0x00150DEB
		public vtkImprintFilter(IntPtr rawCppThis, bool callDisposalMethod, bool strong) : base(rawCppThis, callDisposalMethod, strong)
		{
		}

		// Token: 0x0600F321 RID: 62241
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_New(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F322 RID: 62242 RVA: 0x00152BFC File Offset: 0x00150DFC
		public new static vtkImprintFilter New()
		{
			vtkImprintFilter result = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_New(ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				result = (vtkImprintFilter)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
			}
			return result;
		}

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F323 RID: 62243 RVA: 0x00152C50 File Offset: 0x00150E50
		public vtkImprintFilter() : base(IntPtr.Zero, false, false)
		{
			uint num = 0U;
			uint maxValue = uint.MaxValue;
			uint num2 = 0U;
			IntPtr rawCppThis = vtkImprintFilter.vtkImprintFilter_New(ref num, ref maxValue, ref num2);
			base.SetCppThis(rawCppThis, true, num != 0U && num2 >= 2U);
		}

		/// <summary>
		/// Automatically generated protected Dispose method - called from
		/// public Dispose or the C# destructor. DO NOT call directly.
		/// </summary>
		// Token: 0x0600F324 RID: 62244 RVA: 0x00152C94 File Offset: 0x00150E94
		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		// Token: 0x0600F325 RID: 62245
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_BoundaryEdgeInsertionOff_01(HandleRef pThis);

		/// <summary>
		/// Indicate whether to insert just the boundary edges of the imprint mesh
		/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
		/// used by exactly one cell.) If inserting boundary edges, the imprint
		/// operation is similar to a cookie cutter operation. By default, boundary
		/// edge insertion is off.
		/// </summary>
		// Token: 0x0600F326 RID: 62246 RVA: 0x00152C9F File Offset: 0x00150E9F
		public virtual void BoundaryEdgeInsertionOff()
		{
			vtkImprintFilter.vtkImprintFilter_BoundaryEdgeInsertionOff_01(base.GetCppThis());
		}

		// Token: 0x0600F327 RID: 62247
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_BoundaryEdgeInsertionOn_02(HandleRef pThis);

		/// <summary>
		/// Indicate whether to insert just the boundary edges of the imprint mesh
		/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
		/// used by exactly one cell.) If inserting boundary edges, the imprint
		/// operation is similar to a cookie cutter operation. By default, boundary
		/// edge insertion is off.
		/// </summary>
		// Token: 0x0600F328 RID: 62248 RVA: 0x00152CAE File Offset: 0x00150EAE
		public virtual void BoundaryEdgeInsertionOn()
		{
			vtkImprintFilter.vtkImprintFilter_BoundaryEdgeInsertionOn_02(base.GetCppThis());
		}

		// Token: 0x0600F329 RID: 62249
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte vtkImprintFilter_GetBoundaryEdgeInsertion_03(HandleRef pThis);

		/// <summary>
		/// Indicate whether to insert just the boundary edges of the imprint mesh
		/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
		/// used by exactly one cell.) If inserting boundary edges, the imprint
		/// operation is similar to a cookie cutter operation. By default, boundary
		/// edge insertion is off.
		/// </summary>
		// Token: 0x0600F32A RID: 62250 RVA: 0x00152CC0 File Offset: 0x00150EC0
		public virtual bool GetBoundaryEdgeInsertion()
		{
			return vtkImprintFilter.vtkImprintFilter_GetBoundaryEdgeInsertion_03(base.GetCppThis()) != 0;
		}

		// Token: 0x0600F32B RID: 62251
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkImprintFilter_GetDebugCellId_04(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F32C RID: 62252 RVA: 0x00152CE8 File Offset: 0x00150EE8
		public virtual long GetDebugCellId()
		{
			return vtkImprintFilter.vtkImprintFilter_GetDebugCellId_04(base.GetCppThis());
		}

		// Token: 0x0600F32D RID: 62253
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_GetDebugOutput_05(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Get the output data (in the second output, if the DebugOutput !=
		/// NO_DEBUG_OUTPUT).
		/// </summary>
		// Token: 0x0600F32E RID: 62254 RVA: 0x00152D08 File Offset: 0x00150F08
		public vtkPolyData GetDebugOutput()
		{
			vtkPolyData vtkPolyData = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_GetDebugOutput_05(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkPolyData = (vtkPolyData)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkPolyData.Register(null);
				}
			}
			return vtkPolyData;
		}

		// Token: 0x0600F32F RID: 62255
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetDebugOutputType_06(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F330 RID: 62256 RVA: 0x00152D78 File Offset: 0x00150F78
		public virtual int GetDebugOutputType()
		{
			return vtkImprintFilter.vtkImprintFilter_GetDebugOutputType_06(base.GetCppThis());
		}

		// Token: 0x0600F331 RID: 62257
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetDebugOutputTypeMaxValue_07(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F332 RID: 62258 RVA: 0x00152D98 File Offset: 0x00150F98
		public virtual int GetDebugOutputTypeMaxValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetDebugOutputTypeMaxValue_07(base.GetCppThis());
		}

		// Token: 0x0600F333 RID: 62259
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetDebugOutputTypeMinValue_08(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F334 RID: 62260 RVA: 0x00152DB8 File Offset: 0x00150FB8
		public virtual int GetDebugOutputTypeMinValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetDebugOutputTypeMinValue_08(base.GetCppThis());
		}

		// Token: 0x0600F335 RID: 62261
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_GetImprint_09(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Specify the a second vtkPolyData input which defines the surface mesh
		/// with which to imprint the target (i.e., the first input).
		/// </summary>
		// Token: 0x0600F336 RID: 62262 RVA: 0x00152DD8 File Offset: 0x00150FD8
		public vtkDataObject GetImprint()
		{
			vtkDataObject vtkDataObject = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_GetImprint_09(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkDataObject = (vtkDataObject)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkDataObject.Register(null);
				}
			}
			return vtkDataObject;
		}

		// Token: 0x0600F337 RID: 62263
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_GetImprintConnection_10(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Specify the a second vtkPolyData input connection which defines the
		/// surface mesh with which to imprint the target (the target is provided by
		/// the first input).
		/// </summary>
		// Token: 0x0600F338 RID: 62264 RVA: 0x00152E48 File Offset: 0x00151048
		public vtkAlgorithmOutput GetImprintConnection()
		{
			vtkAlgorithmOutput vtkAlgorithmOutput = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_GetImprintConnection_10(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkAlgorithmOutput = (vtkAlgorithmOutput)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkAlgorithmOutput.Register(null);
				}
			}
			return vtkAlgorithmOutput;
		}

		// Token: 0x0600F339 RID: 62265
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern double vtkImprintFilter_GetMergeTolerance_11(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F33A RID: 62266 RVA: 0x00152EB8 File Offset: 0x001510B8
		public virtual double GetMergeTolerance()
		{
			return vtkImprintFilter.vtkImprintFilter_GetMergeTolerance_11(base.GetCppThis());
		}

		// Token: 0x0600F33B RID: 62267
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern double vtkImprintFilter_GetMergeToleranceMaxValue_12(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F33C RID: 62268 RVA: 0x00152ED8 File Offset: 0x001510D8
		public virtual double GetMergeToleranceMaxValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetMergeToleranceMaxValue_12(base.GetCppThis());
		}

		// Token: 0x0600F33D RID: 62269
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern double vtkImprintFilter_GetMergeToleranceMinValue_13(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F33E RID: 62270 RVA: 0x00152EF8 File Offset: 0x001510F8
		public virtual double GetMergeToleranceMinValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetMergeToleranceMinValue_13(base.GetCppThis());
		}

		// Token: 0x0600F33F RID: 62271
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetMergeToleranceType_14(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F340 RID: 62272 RVA: 0x00152F18 File Offset: 0x00151118
		public virtual int GetMergeToleranceType()
		{
			return vtkImprintFilter.vtkImprintFilter_GetMergeToleranceType_14(base.GetCppThis());
		}

		// Token: 0x0600F341 RID: 62273
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetMergeToleranceTypeMaxValue_15(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F342 RID: 62274 RVA: 0x00152F38 File Offset: 0x00151138
		public virtual int GetMergeToleranceTypeMaxValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetMergeToleranceTypeMaxValue_15(base.GetCppThis());
		}

		// Token: 0x0600F343 RID: 62275
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetMergeToleranceTypeMinValue_16(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F344 RID: 62276 RVA: 0x00152F58 File Offset: 0x00151158
		public virtual int GetMergeToleranceTypeMinValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetMergeToleranceTypeMinValue_16(base.GetCppThis());
		}

		// Token: 0x0600F345 RID: 62277
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkImprintFilter_GetNumberOfGenerationsFromBase_17(HandleRef pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F346 RID: 62278 RVA: 0x00152F78 File Offset: 0x00151178
		public override long GetNumberOfGenerationsFromBase(string type)
		{
			return vtkImprintFilter.vtkImprintFilter_GetNumberOfGenerationsFromBase_17(base.GetCppThis(), type);
		}

		// Token: 0x0600F347 RID: 62279
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern long vtkImprintFilter_GetNumberOfGenerationsFromBaseType_18([MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F348 RID: 62280 RVA: 0x00152F98 File Offset: 0x00151198
		public new static long GetNumberOfGenerationsFromBaseType(string type)
		{
			return vtkImprintFilter.vtkImprintFilter_GetNumberOfGenerationsFromBaseType_18(type);
		}

		// Token: 0x0600F349 RID: 62281
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetOutputType_19(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F34A RID: 62282 RVA: 0x00152FB4 File Offset: 0x001511B4
		public virtual int GetOutputType()
		{
			return vtkImprintFilter.vtkImprintFilter_GetOutputType_19(base.GetCppThis());
		}

		// Token: 0x0600F34B RID: 62283
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetOutputTypeMaxValue_20(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F34C RID: 62284 RVA: 0x00152FD4 File Offset: 0x001511D4
		public virtual int GetOutputTypeMaxValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetOutputTypeMaxValue_20(base.GetCppThis());
		}

		// Token: 0x0600F34D RID: 62285
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetOutputTypeMinValue_21(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F34E RID: 62286 RVA: 0x00152FF4 File Offset: 0x001511F4
		public virtual int GetOutputTypeMinValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetOutputTypeMinValue_21(base.GetCppThis());
		}

		// Token: 0x0600F34F RID: 62287
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte vtkImprintFilter_GetPassCellData_22(HandleRef pThis);

		/// <summary>
		/// Indicate whether cell data from the input target is to be passed through
		/// to the output mesh. By default, PassCellData is enabled.
		/// </summary>
		// Token: 0x0600F350 RID: 62288 RVA: 0x00153014 File Offset: 0x00151214
		public virtual bool GetPassCellData()
		{
			return vtkImprintFilter.vtkImprintFilter_GetPassCellData_22(base.GetCppThis()) != 0;
		}

		// Token: 0x0600F351 RID: 62289
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte vtkImprintFilter_GetPassPointData_23(HandleRef pThis);

		/// <summary>
		/// Indicate whether point data from the input target mesh and the imprint
		/// mesh are to be passed through and/or interpolated to the output mesh. By
		/// default, PassPointData is enabled. Note: both the input mesh points and
		/// the imprint points must have identical point data. Otherwise, a set
		/// intersection operation will be performed to process just the point data
		/// arrays common to both the mesh point data and imprint point data.
		/// </summary>
		// Token: 0x0600F352 RID: 62290 RVA: 0x0015303C File Offset: 0x0015123C
		public virtual bool GetPassPointData()
		{
			return vtkImprintFilter.vtkImprintFilter_GetPassPointData_23(base.GetCppThis()) != 0;
		}

		// Token: 0x0600F353 RID: 62291
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetPointInterpolation_24(HandleRef pThis);

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0600F354 RID: 62292 RVA: 0x00153064 File Offset: 0x00151264
		public virtual int GetPointInterpolation()
		{
			return vtkImprintFilter.vtkImprintFilter_GetPointInterpolation_24(base.GetCppThis());
		}

		// Token: 0x0600F355 RID: 62293
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetPointInterpolationMaxValue_25(HandleRef pThis);

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0600F356 RID: 62294 RVA: 0x00153084 File Offset: 0x00151284
		public virtual int GetPointInterpolationMaxValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetPointInterpolationMaxValue_25(base.GetCppThis());
		}

		// Token: 0x0600F357 RID: 62295
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_GetPointInterpolationMinValue_26(HandleRef pThis);

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0600F358 RID: 62296 RVA: 0x001530A4 File Offset: 0x001512A4
		public virtual int GetPointInterpolationMinValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetPointInterpolationMinValue_26(base.GetCppThis());
		}

		// Token: 0x0600F359 RID: 62297
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_GetTarget_27(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Specify the first vtkPolyData input which defines the surface mesh to
		/// imprint (i.e., the taregt). The imprint surface is provided by the
		/// second input.
		/// </summary>
		// Token: 0x0600F35A RID: 62298 RVA: 0x001530C4 File Offset: 0x001512C4
		public vtkDataObject GetTarget()
		{
			vtkDataObject vtkDataObject = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_GetTarget_27(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkDataObject = (vtkDataObject)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkDataObject.Register(null);
				}
			}
			return vtkDataObject;
		}

		// Token: 0x0600F35B RID: 62299
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_GetTargetConnection_28(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Specify the first vtkPolyData input connection which defines the
		/// surface mesh to imprint (i.e., the target).
		/// </summary>
		// Token: 0x0600F35C RID: 62300 RVA: 0x00153134 File Offset: 0x00151334
		public vtkAlgorithmOutput GetTargetConnection()
		{
			vtkAlgorithmOutput vtkAlgorithmOutput = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_GetTargetConnection_28(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkAlgorithmOutput = (vtkAlgorithmOutput)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkAlgorithmOutput.Register(null);
				}
			}
			return vtkAlgorithmOutput;
		}

		// Token: 0x0600F35D RID: 62301
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern double vtkImprintFilter_GetTolerance_29(HandleRef pThis);

		/// <summary>
		/// Specify a projection tolerance which controls how close the imprint
		/// surface must be to the target to successfully imprint the surface. This
		/// is an absolute value.
		/// </summary>
		// Token: 0x0600F35E RID: 62302 RVA: 0x001531A4 File Offset: 0x001513A4
		public virtual double GetTolerance()
		{
			return vtkImprintFilter.vtkImprintFilter_GetTolerance_29(base.GetCppThis());
		}

		// Token: 0x0600F35F RID: 62303
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern double vtkImprintFilter_GetToleranceMaxValue_30(HandleRef pThis);

		/// <summary>
		/// Specify a projection tolerance which controls how close the imprint
		/// surface must be to the target to successfully imprint the surface. This
		/// is an absolute value.
		/// </summary>
		// Token: 0x0600F360 RID: 62304 RVA: 0x001531C4 File Offset: 0x001513C4
		public virtual double GetToleranceMaxValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetToleranceMaxValue_30(base.GetCppThis());
		}

		// Token: 0x0600F361 RID: 62305
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern double vtkImprintFilter_GetToleranceMinValue_31(HandleRef pThis);

		/// <summary>
		/// Specify a projection tolerance which controls how close the imprint
		/// surface must be to the target to successfully imprint the surface. This
		/// is an absolute value.
		/// </summary>
		// Token: 0x0600F362 RID: 62306 RVA: 0x001531E4 File Offset: 0x001513E4
		public virtual double GetToleranceMinValue()
		{
			return vtkImprintFilter.vtkImprintFilter_GetToleranceMinValue_31(base.GetCppThis());
		}

		// Token: 0x0600F363 RID: 62307
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern byte vtkImprintFilter_GetTriangulateOutput_32(HandleRef pThis);

		/// <summary>
		/// Indicate whether the output should be triangulated. By default (i.e.,
		/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
		/// target cell boundaries, will not be triangulated. (Cells in the
		/// transition region are always triangulated because they are frequently
		/// concave.)
		/// </summary>
		// Token: 0x0600F364 RID: 62308 RVA: 0x00153204 File Offset: 0x00151404
		public virtual bool GetTriangulateOutput()
		{
			return vtkImprintFilter.vtkImprintFilter_GetTriangulateOutput_32(base.GetCppThis()) != 0;
		}

		// Token: 0x0600F365 RID: 62309
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_IsA_33(HandleRef pThis, [MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F366 RID: 62310 RVA: 0x0015322C File Offset: 0x0015142C
		public override int IsA(string type)
		{
			return vtkImprintFilter.vtkImprintFilter_IsA_33(base.GetCppThis(), type);
		}

		// Token: 0x0600F367 RID: 62311
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern int vtkImprintFilter_IsTypeOf_34([MarshalAs(UnmanagedType.LPUTF8Str)] string type);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F368 RID: 62312 RVA: 0x0015324C File Offset: 0x0015144C
		public new static int IsTypeOf(string type)
		{
			return vtkImprintFilter.vtkImprintFilter_IsTypeOf_34(type);
		}

		// Token: 0x0600F369 RID: 62313
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_NewInstance_36(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F36A RID: 62314 RVA: 0x00153268 File Offset: 0x00151468
		public new vtkImprintFilter NewInstance()
		{
			vtkImprintFilter result = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_NewInstance_36(base.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				result = (vtkImprintFilter)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
			}
			return result;
		}

		// Token: 0x0600F36B RID: 62315
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_PassCellDataOff_37(HandleRef pThis);

		/// <summary>
		/// Indicate whether cell data from the input target is to be passed through
		/// to the output mesh. By default, PassCellData is enabled.
		/// </summary>
		// Token: 0x0600F36C RID: 62316 RVA: 0x001532C2 File Offset: 0x001514C2
		public virtual void PassCellDataOff()
		{
			vtkImprintFilter.vtkImprintFilter_PassCellDataOff_37(base.GetCppThis());
		}

		// Token: 0x0600F36D RID: 62317
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_PassCellDataOn_38(HandleRef pThis);

		/// <summary>
		/// Indicate whether cell data from the input target is to be passed through
		/// to the output mesh. By default, PassCellData is enabled.
		/// </summary>
		// Token: 0x0600F36E RID: 62318 RVA: 0x001532D1 File Offset: 0x001514D1
		public virtual void PassCellDataOn()
		{
			vtkImprintFilter.vtkImprintFilter_PassCellDataOn_38(base.GetCppThis());
		}

		// Token: 0x0600F36F RID: 62319
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_PassPointDataOff_39(HandleRef pThis);

		/// <summary>
		/// Indicate whether point data from the input target mesh and the imprint
		/// mesh are to be passed through and/or interpolated to the output mesh. By
		/// default, PassPointData is enabled. Note: both the input mesh points and
		/// the imprint points must have identical point data. Otherwise, a set
		/// intersection operation will be performed to process just the point data
		/// arrays common to both the mesh point data and imprint point data.
		/// </summary>
		// Token: 0x0600F370 RID: 62320 RVA: 0x001532E0 File Offset: 0x001514E0
		public virtual void PassPointDataOff()
		{
			vtkImprintFilter.vtkImprintFilter_PassPointDataOff_39(base.GetCppThis());
		}

		// Token: 0x0600F371 RID: 62321
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_PassPointDataOn_40(HandleRef pThis);

		/// <summary>
		/// Indicate whether point data from the input target mesh and the imprint
		/// mesh are to be passed through and/or interpolated to the output mesh. By
		/// default, PassPointData is enabled. Note: both the input mesh points and
		/// the imprint points must have identical point data. Otherwise, a set
		/// intersection operation will be performed to process just the point data
		/// arrays common to both the mesh point data and imprint point data.
		/// </summary>
		// Token: 0x0600F372 RID: 62322 RVA: 0x001532EF File Offset: 0x001514EF
		public virtual void PassPointDataOn()
		{
			vtkImprintFilter.vtkImprintFilter_PassPointDataOn_40(base.GetCppThis());
		}

		// Token: 0x0600F373 RID: 62323
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr vtkImprintFilter_SafeDownCast_41(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

		/// <summary>
		/// Standard methods to instantiate, print and provide type information.
		/// </summary>
		// Token: 0x0600F374 RID: 62324 RVA: 0x00153300 File Offset: 0x00151500
		public new static vtkImprintFilter SafeDownCast(vtkObjectBase o)
		{
			vtkImprintFilter vtkImprintFilter = null;
			uint mteStatus = 0U;
			uint maxValue = uint.MaxValue;
			uint rawRefCount = 0U;
			IntPtr intPtr = vtkImprintFilter.vtkImprintFilter_SafeDownCast_41((o == null) ? default(HandleRef) : o.GetCppThis(), ref mteStatus, ref maxValue, ref rawRefCount);
			if (IntPtr.Zero != intPtr)
			{
				bool flag;
				vtkImprintFilter = (vtkImprintFilter)Methods.CreateWrappedObject(mteStatus, maxValue, rawRefCount, intPtr, true, out flag);
				if (flag)
				{
					vtkImprintFilter.Register(null);
				}
			}
			return vtkImprintFilter;
		}

		// Token: 0x0600F375 RID: 62325
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetBoundaryEdgeInsertion_42(HandleRef pThis, byte _arg);

		/// <summary>
		/// Indicate whether to insert just the boundary edges of the imprint mesh
		/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
		/// used by exactly one cell.) If inserting boundary edges, the imprint
		/// operation is similar to a cookie cutter operation. By default, boundary
		/// edge insertion is off.
		/// </summary>
		// Token: 0x0600F376 RID: 62326 RVA: 0x0015337F File Offset: 0x0015157F
		public virtual void SetBoundaryEdgeInsertion(bool _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetBoundaryEdgeInsertion_42(base.GetCppThis(), _arg ? (byte)1 : (byte)0);
		}

		// Token: 0x0600F377 RID: 62327
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetDebugCellId_43(HandleRef pThis, long _arg);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F378 RID: 62328 RVA: 0x00153397 File Offset: 0x00151597
		public virtual void SetDebugCellId(long _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetDebugCellId_43(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F379 RID: 62329
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetDebugOutputType_44(HandleRef pThis, int _arg);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F37A RID: 62330 RVA: 0x001533A7 File Offset: 0x001515A7
		public virtual void SetDebugOutputType(int _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetDebugOutputType_44(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F37B RID: 62331
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetDebugOutputTypeToNoDebugOutput_45(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F37C RID: 62332 RVA: 0x001533B7 File Offset: 0x001515B7
		public void SetDebugOutputTypeToNoDebugOutput()
		{
			vtkImprintFilter.vtkImprintFilter_SetDebugOutputTypeToNoDebugOutput_45(base.GetCppThis());
		}

		// Token: 0x0600F37D RID: 62333
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetDebugOutputTypeToTriangulationInput_46(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F37E RID: 62334 RVA: 0x001533C6 File Offset: 0x001515C6
		public void SetDebugOutputTypeToTriangulationInput()
		{
			vtkImprintFilter.vtkImprintFilter_SetDebugOutputTypeToTriangulationInput_46(base.GetCppThis());
		}

		// Token: 0x0600F37F RID: 62335
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetDebugOutputTypeToTriangulationOutput_47(HandleRef pThis);

		/// <summary>
		/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
		/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
		/// is set, then the input points and edges contained by the target DebugCellId are
		/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
		/// set, then the output triangulation for the specified target cellId is
		/// placed in a second output to this filter.
		/// </summary>
		// Token: 0x0600F380 RID: 62336 RVA: 0x001533D5 File Offset: 0x001515D5
		public void SetDebugOutputTypeToTriangulationOutput()
		{
			vtkImprintFilter.vtkImprintFilter_SetDebugOutputTypeToTriangulationOutput_47(base.GetCppThis());
		}

		// Token: 0x0600F381 RID: 62337
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetImprintConnection_48(HandleRef pThis, HandleRef algOutput);

		/// <summary>
		/// Specify the a second vtkPolyData input connection which defines the
		/// surface mesh with which to imprint the target (the target is provided by
		/// the first input).
		/// </summary>
		// Token: 0x0600F382 RID: 62338 RVA: 0x001533E4 File Offset: 0x001515E4
		public void SetImprintConnection(vtkAlgorithmOutput algOutput)
		{
			vtkImprintFilter.vtkImprintFilter_SetImprintConnection_48(base.GetCppThis(), (algOutput == null) ? default(HandleRef) : algOutput.GetCppThis());
		}

		// Token: 0x0600F383 RID: 62339
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetImprintData_49(HandleRef pThis, HandleRef imprint);

		/// <summary>
		/// Specify the a second vtkPolyData input which defines the surface mesh
		/// with which to imprint the target (i.e., the first input).
		/// </summary>
		// Token: 0x0600F384 RID: 62340 RVA: 0x00153414 File Offset: 0x00151614
		public void SetImprintData(vtkDataObject imprint)
		{
			vtkImprintFilter.vtkImprintFilter_SetImprintData_49(base.GetCppThis(), (imprint == null) ? default(HandleRef) : imprint.GetCppThis());
		}

		// Token: 0x0600F385 RID: 62341
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetMergeTolerance_50(HandleRef pThis, double _arg);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F386 RID: 62342 RVA: 0x00153443 File Offset: 0x00151643
		public virtual void SetMergeTolerance(double _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetMergeTolerance_50(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F387 RID: 62343
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetMergeToleranceType_51(HandleRef pThis, int _arg);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F388 RID: 62344 RVA: 0x00153453 File Offset: 0x00151653
		public virtual void SetMergeToleranceType(int _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetMergeToleranceType_51(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F389 RID: 62345
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetMergeToleranceTypeToAbsolute_52(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F38A RID: 62346 RVA: 0x00153463 File Offset: 0x00151663
		public void SetMergeToleranceTypeToAbsolute()
		{
			vtkImprintFilter.vtkImprintFilter_SetMergeToleranceTypeToAbsolute_52(base.GetCppThis());
		}

		// Token: 0x0600F38B RID: 62347
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetMergeToleranceTypeToMinEdge_53(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F38C RID: 62348 RVA: 0x00153472 File Offset: 0x00151672
		public void SetMergeToleranceTypeToMinEdge()
		{
			vtkImprintFilter.vtkImprintFilter_SetMergeToleranceTypeToMinEdge_53(base.GetCppThis());
		}

		// Token: 0x0600F38D RID: 62349
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetMergeToleranceTypeToRelativeToProjection_54(HandleRef pThis);

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0600F38E RID: 62350 RVA: 0x00153481 File Offset: 0x00151681
		public void SetMergeToleranceTypeToRelativeToProjection()
		{
			vtkImprintFilter.vtkImprintFilter_SetMergeToleranceTypeToRelativeToProjection_54(base.GetCppThis());
		}

		// Token: 0x0600F38F RID: 62351
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetOutputType_55(HandleRef pThis, int _arg);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F390 RID: 62352 RVA: 0x00153490 File Offset: 0x00151690
		public virtual void SetOutputType(int _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetOutputType_55(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F391 RID: 62353
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetOutputTypeToImprintedCells_56(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F392 RID: 62354 RVA: 0x001534A0 File Offset: 0x001516A0
		public void SetOutputTypeToImprintedCells()
		{
			vtkImprintFilter.vtkImprintFilter_SetOutputTypeToImprintedCells_56(base.GetCppThis());
		}

		// Token: 0x0600F393 RID: 62355
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetOutputTypeToImprintedRegion_57(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F394 RID: 62356 RVA: 0x001534AF File Offset: 0x001516AF
		public void SetOutputTypeToImprintedRegion()
		{
			vtkImprintFilter.vtkImprintFilter_SetOutputTypeToImprintedRegion_57(base.GetCppThis());
		}

		// Token: 0x0600F395 RID: 62357
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetOutputTypeToMergedImprint_58(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F396 RID: 62358 RVA: 0x001534BE File Offset: 0x001516BE
		public void SetOutputTypeToMergedImprint()
		{
			vtkImprintFilter.vtkImprintFilter_SetOutputTypeToMergedImprint_58(base.GetCppThis());
		}

		// Token: 0x0600F397 RID: 62359
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetOutputTypeToProjectedImprint_59(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F398 RID: 62360 RVA: 0x001534CD File Offset: 0x001516CD
		public void SetOutputTypeToProjectedImprint()
		{
			vtkImprintFilter.vtkImprintFilter_SetOutputTypeToProjectedImprint_59(base.GetCppThis());
		}

		// Token: 0x0600F399 RID: 62361
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetOutputTypeToTargetCells_60(HandleRef pThis);

		/// <summary>
		/// Control what is output by the filter. This can be useful for debugging
		/// or to extract portions of the data. The choices are: TARGET_CELLS -
		/// output the target cells in contact (relative to the tolerance) of the
		/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
		/// after intersection and triangulation with the imprint mesh;
		/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
		/// modififying the imprint mesh point coordinates to lie on the target
		/// mesh; IMPRINTED_REGION - extract just the area of contact between the
		/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
		/// mesh after the imprint operation. By default, MERGED_IMPRINT is
		/// produced.
		/// </summary>
		// Token: 0x0600F39A RID: 62362 RVA: 0x001534DC File Offset: 0x001516DC
		public void SetOutputTypeToTargetCells()
		{
			vtkImprintFilter.vtkImprintFilter_SetOutputTypeToTargetCells_60(base.GetCppThis());
		}

		// Token: 0x0600F39B RID: 62363
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetPassCellData_61(HandleRef pThis, byte _arg);

		/// <summary>
		/// Indicate whether cell data from the input target is to be passed through
		/// to the output mesh. By default, PassCellData is enabled.
		/// </summary>
		// Token: 0x0600F39C RID: 62364 RVA: 0x001534EB File Offset: 0x001516EB
		public virtual void SetPassCellData(bool _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetPassCellData_61(base.GetCppThis(), _arg ? (byte)1 : (byte)0);
		}

		// Token: 0x0600F39D RID: 62365
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetPassPointData_62(HandleRef pThis, byte _arg);

		/// <summary>
		/// Indicate whether point data from the input target mesh and the imprint
		/// mesh are to be passed through and/or interpolated to the output mesh. By
		/// default, PassPointData is enabled. Note: both the input mesh points and
		/// the imprint points must have identical point data. Otherwise, a set
		/// intersection operation will be performed to process just the point data
		/// arrays common to both the mesh point data and imprint point data.
		/// </summary>
		// Token: 0x0600F39E RID: 62366 RVA: 0x00153503 File Offset: 0x00151703
		public virtual void SetPassPointData(bool _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetPassPointData_62(base.GetCppThis(), _arg ? (byte)1 : (byte)0);
		}

		// Token: 0x0600F39F RID: 62367
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetPointInterpolation_63(HandleRef pThis, int _arg);

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0600F3A0 RID: 62368 RVA: 0x0015351B File Offset: 0x0015171B
		public virtual void SetPointInterpolation(int _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetPointInterpolation_63(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F3A1 RID: 62369
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetPointInterpolationToImprintEdges_64(HandleRef pThis);

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0600F3A2 RID: 62370 RVA: 0x0015352B File Offset: 0x0015172B
		public void SetPointInterpolationToImprintEdges()
		{
			vtkImprintFilter.vtkImprintFilter_SetPointInterpolationToImprintEdges_64(base.GetCppThis());
		}

		// Token: 0x0600F3A3 RID: 62371
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetPointInterpolationToTargetEdges_65(HandleRef pThis);

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0600F3A4 RID: 62372 RVA: 0x0015353A File Offset: 0x0015173A
		public void SetPointInterpolationToTargetEdges()
		{
			vtkImprintFilter.vtkImprintFilter_SetPointInterpolationToTargetEdges_65(base.GetCppThis());
		}

		// Token: 0x0600F3A5 RID: 62373
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetTargetConnection_66(HandleRef pThis, HandleRef algOutput);

		/// <summary>
		/// Specify the first vtkPolyData input connection which defines the
		/// surface mesh to imprint (i.e., the target).
		/// </summary>
		// Token: 0x0600F3A6 RID: 62374 RVA: 0x0015354C File Offset: 0x0015174C
		public void SetTargetConnection(vtkAlgorithmOutput algOutput)
		{
			vtkImprintFilter.vtkImprintFilter_SetTargetConnection_66(base.GetCppThis(), (algOutput == null) ? default(HandleRef) : algOutput.GetCppThis());
		}

		// Token: 0x0600F3A7 RID: 62375
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetTargetData_67(HandleRef pThis, HandleRef target);

		/// <summary>
		/// Specify the first vtkPolyData input which defines the surface mesh to
		/// imprint (i.e., the taregt). The imprint surface is provided by the
		/// second input.
		/// </summary>
		// Token: 0x0600F3A8 RID: 62376 RVA: 0x0015357C File Offset: 0x0015177C
		public void SetTargetData(vtkDataObject target)
		{
			vtkImprintFilter.vtkImprintFilter_SetTargetData_67(base.GetCppThis(), (target == null) ? default(HandleRef) : target.GetCppThis());
		}

		// Token: 0x0600F3A9 RID: 62377
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetTolerance_68(HandleRef pThis, double _arg);

		/// <summary>
		/// Specify a projection tolerance which controls how close the imprint
		/// surface must be to the target to successfully imprint the surface. This
		/// is an absolute value.
		/// </summary>
		// Token: 0x0600F3AA RID: 62378 RVA: 0x001535AB File Offset: 0x001517AB
		public virtual void SetTolerance(double _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetTolerance_68(base.GetCppThis(), _arg);
		}

		// Token: 0x0600F3AB RID: 62379
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_SetTriangulateOutput_69(HandleRef pThis, byte _arg);

		/// <summary>
		/// Indicate whether the output should be triangulated. By default (i.e.,
		/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
		/// target cell boundaries, will not be triangulated. (Cells in the
		/// transition region are always triangulated because they are frequently
		/// concave.)
		/// </summary>
		// Token: 0x0600F3AC RID: 62380 RVA: 0x001535BB File Offset: 0x001517BB
		public virtual void SetTriangulateOutput(bool _arg)
		{
			vtkImprintFilter.vtkImprintFilter_SetTriangulateOutput_69(base.GetCppThis(), _arg ? (byte)1 : (byte)0);
		}

		// Token: 0x0600F3AD RID: 62381
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_TriangulateOutputOff_70(HandleRef pThis);

		/// <summary>
		/// Indicate whether the output should be triangulated. By default (i.e.,
		/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
		/// target cell boundaries, will not be triangulated. (Cells in the
		/// transition region are always triangulated because they are frequently
		/// concave.)
		/// </summary>
		// Token: 0x0600F3AE RID: 62382 RVA: 0x001535D3 File Offset: 0x001517D3
		public virtual void TriangulateOutputOff()
		{
			vtkImprintFilter.vtkImprintFilter_TriangulateOutputOff_70(base.GetCppThis());
		}

		// Token: 0x0600F3AF RID: 62383
		[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
		internal static extern void vtkImprintFilter_TriangulateOutputOn_71(HandleRef pThis);

		/// <summary>
		/// Indicate whether the output should be triangulated. By default (i.e.,
		/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
		/// target cell boundaries, will not be triangulated. (Cells in the
		/// transition region are always triangulated because they are frequently
		/// concave.)
		/// </summary>
		// Token: 0x0600F3B0 RID: 62384 RVA: 0x001535E2 File Offset: 0x001517E2
		public virtual void TriangulateOutputOn()
		{
			vtkImprintFilter.vtkImprintFilter_TriangulateOutputOn_71(base.GetCppThis());
		}

		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x040011B6 RID: 4534
		public new const string MRFullTypeName = "Kitware.VTK.vtkImprintFilter";

		/// <summary>
		/// Automatically generated type registration mechanics.
		/// </summary>
		// Token: 0x040011B7 RID: 4535
		public new static readonly string MRClassNameKey = "class vtkImprintFilter";

		/// <summary>
		/// If PassPointData is on, indicate how new point data is to generated at
		/// the intersection points between the input target mesh edges and the
		/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
		/// </summary>
		// Token: 0x0200055B RID: 1371
		public enum DebugOutput
		{
			/// <summary>enum member</summary>
			// Token: 0x040011B9 RID: 4537
			NO_DEBUG_OUTPUT,
			/// <summary>enum member</summary>
			// Token: 0x040011BA RID: 4538
			TRIANGULATION_INPUT,
			/// <summary>enum member</summary>
			// Token: 0x040011BB RID: 4539
			TRIANGULATION_OUTPUT
		}

		/// <summary>
		/// Specify a projection tolerance which controls how close the imprint
		/// surface must be to the target to successfully imprint the surface. This
		/// is an absolute value.
		/// </summary>
		// Token: 0x0200055C RID: 1372
		public enum MergeTolType
		{
			/// <summary>enum member</summary>
			// Token: 0x040011BD RID: 4541
			ABSOLUTE_TOLERANCE,
			/// <summary>enum member</summary>
			// Token: 0x040011BE RID: 4542
			RELATIVE_TO_MIN_EDGE_LENGTH = 2,
			/// <summary>enum member</summary>
			// Token: 0x040011BF RID: 4543
			RELATIVE_TO_PROJECTION_TOLERANCE = 1
		}

		/// <summary>
		/// Indicate whether point data from the input target mesh and the imprint
		/// mesh are to be passed through and/or interpolated to the output mesh. By
		/// default, PassPointData is enabled. Note: both the input mesh points and
		/// the imprint points must have identical point data. Otherwise, a set
		/// intersection operation will be performed to process just the point data
		/// arrays common to both the mesh point data and imprint point data.
		/// </summary>
		// Token: 0x0200055D RID: 1373
		public enum PointInterpolationType
		{
			/// <summary>enum member</summary>
			// Token: 0x040011C1 RID: 4545
			USE_IMPRINT_EDGES = 1,
			/// <summary>enum member</summary>
			// Token: 0x040011C2 RID: 4546
			USE_TARGET_EDGES = 0
		}

		/// <summary>
		/// Specify a tolerance which is used to determine whether two points are
		/// considered coincident to one another. This is important when performing
		/// intersections and projections to reduce numerical issues.
		/// </summary>
		// Token: 0x0200055E RID: 1374
		public enum SpecifiedOutput
		{
			/// <summary>enum member</summary>
			// Token: 0x040011C4 RID: 4548
			IMPRINTED_CELLS = 1,
			/// <summary>enum member</summary>
			// Token: 0x040011C5 RID: 4549
			IMPRINTED_REGION = 3,
			/// <summary>enum member</summary>
			// Token: 0x040011C6 RID: 4550
			MERGED_IMPRINT = 5,
			/// <summary>enum member</summary>
			// Token: 0x040011C7 RID: 4551
			PROJECTED_IMPRINT = 2,
			/// <summary>enum member</summary>
			// Token: 0x040011C8 RID: 4552
			TARGET_CELLS = 0
		}
	}
}
